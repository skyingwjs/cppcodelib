#pragma once
#ifndef __OFFER_H__
#define __OFFER_H__
#include <iostream>
#include <string>
#include <sstream>
#include <vector>
#include <iterator>
#include <stack>
#include <set>
#include <queue>
#include <map>
#include <cmath>
//#include <regex.h>
using namespace std;
/*链表结点*/
typedef struct ListNode{
	int val;
	ListNode *next;
	ListNode(int x):val(x),next(NULL){

	}
}ListNode; 

/*随机链表结点*/
typedef struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
}RandomListNode;


/*二叉树结点*/
typedef struct TreeNode{
	int val;
	TreeNode * left;
	TreeNode * right;
	TreeNode(int x):val(x),left(NULL),right(NULL){

	}
}TreeNode;


typedef struct TreeLinkNode {
	int val;
	struct TreeLinkNode *left;
	struct TreeLinkNode *right;
	struct TreeLinkNode *next;
	TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {

	}
}TreeLinkNode;



class Solution{
private:
	stack<int> stack1;
	stack<int> stack2;
	/*********************************************************************************************
	T1：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
	请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
	思路:矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，
		因此从左下角开始查找，当要查找数字比左下角数字大时。右移
		要查找数字比左下角数字小时，上移
	**********************************************************************************************/
public:
	bool find(vector<vector<int> > array,int target);


    /*********************************************************************************************
    T2：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.
	则经过替换之后的字符串为We%20Are%20Happy
	思路：1.从前往后插入，这样移动的次数多不建议
		 2.从后往前插入 
    **********************************************************************************************/
	void replaceSpace(char *str,int length);//length为牛客系统规定字符串输出的最大长度，固定为一个常数



	/*********************************************************************************************
	T3.输入一个链表，从尾到头打印链表每个节点的值。 
	思路1：用库函数，每次扫描一个节点，将该结点数据存入vector中，如果该节点有下一节点，将下一节点数据直接插入
	vector最前面，直至遍历完，或者直接加在最后，最后调用reverse 
	思路2：链表从尾到头输出，利用递归实现，不使用库函数直接printf输出的时候用递归比较好 
	**********************************************************************************************/
	vector<int> printListFromTailToHead( ListNode * head);
	vector<int> printListFromTailToHead2( ListNode* head);

    /*********************************************************************************************
    T4:输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
	例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 
    **********************************************************************************************/
	TreeNode * reconstructBinaryTree(vector<int> pre,vector<int> in);

    /*********************************************************************************************
    T5：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 
	思路：<分析>
	入队：将元素进栈A
	出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；
	如果不为空，栈B直接出栈。

	扩展：用两个队列实现一个栈的功能?要求给出算法和思路!
	入栈：将元素进队列A
	出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素依次出队列并放入队列B，
	直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列依次放入队列A中。 
    **********************************************************************************************/
	void push(int node);
	int pop() ;

	/*********************************************************************************************
	T6:把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，
	输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
	NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 
	思路1： 
	常规解法分三种情况(时间复杂度O(n)，数据量大的时候，效率很低)
	1.数组为空
	2.部分旋转，例如由（1,2,3,4,5）旋转为（3,4,5,1,2），此时只需要遍历数组，找到当前数比前面的数小的数即可。
	3.完全旋转，例如由（1,2,3,4,5）旋转为（1,2,3,4,5），此时第一个数最小。
	思路2：
	二分查找法()
	这道题目考的是二分思想 思路1每次都是全局扫描的思路 能解决问题 但是没什么价值 数据量大了之后两者的效率就出来了
	**********************************************************************************************/
	int minNumberInRotateArray(vector<int> rotateArray);


	/*********************************************************************************************
	剑指Offer中有这道题目的分析。这是一道二分查找的变形的题目。
	旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素
	注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。
	思路：
	（1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。
	但是如果不是旋转，第一个元素肯定小于最后一个元素。

	（2）找到数组的中间元素。
	中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。
	移动之后，第一个指针仍然位于前面的递增数组中。
	中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。
	移动之后，第二个指针仍然位于后面的递增数组中。
	这样可以缩小寻找的范围。

	（3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。
	最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。
	也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。
	到目前为止以上思路很耗的解决了没有重复数字的情况。

	有了重复数字，情况就会不一样：
	我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。
	这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。
	第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。
	因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。
	也就无法移动指针来缩小查找的范围。
	//因此rotateArray[left] rotateArray[right] rotateArray[mid]三者相等时则无法确定 中间元素是属于前面的还是后面的递增子数组 只能顺序查找
	**********************************************************************************************/
	int minNumberInRotateArray2(vector<int> rotateArray);
	int minOrder(vector<int>&rotateArray,int left,int right);


	/*********************************************************************************************
	大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n<=39
	思路1：递归解法 复杂度高 , 因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看程序怎么跑的：
	Fibonacci(4) = Fibonacci(3) + Fibonacci(2);
	= Fibonacci(2) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0);
	= Fibonacci(1) + Fibonacci(0) + Fibonacci(1) + Fibonacci(1) + Fibonacci(0);
	由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。 

	思路2:动态规划
	**********************************************************************************************/
	int fabonacci1(int n);
	int fabonacci2(int n);

	/*********************************************************************************************
	一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
	思路1：跳上第n级台阶只能从 n-1级 或 n-2级 跳上去 所以类似于fabonacci数列 f(n)=f(n-1)+f(n-2) f(1)=1,f(2)=2;
	**********************************************************************************************/
	int jumpFloor(int n);

	/*********************************************************************************************
	一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
	类似于fabonacci数列 f(n)=f(n-1)+f(n-2)+...+f(1)+f(0) (n>=1)    f(0)=1,f(1)=1,f(2)=2;

	分析： 关于本题，前提是n个台阶会有一次n阶的跳法。分析如下:
	f(1) = 1
	f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。
	f(3) = f(3-1) + f(3-2) + f(3-3) 
	...
	f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 
	说明： 
	1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的跳法数。
	2）n = 1时，只有1种跳法，f(1) = 1
	3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 
	4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，
	那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)
	因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)
	5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论：
	f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) => f(0) + f(1) + f(2) + f(3) + ... + f(n-1)
	6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：
	f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)
	f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)
	可以得出：
	f(n) = 2*f(n-1)
	7) 得出最终结论,在n阶台阶，一次有1、2、...n阶的跳的方式时，总得跳法为：
			| 1       ,(n=0 ) 
	f(n) =  | 1       ,(n=1 )
			| 2*f(n-1),(n>=2)
	**********************************************************************************************/
	int jumpFloorII(int n);

	/*********************************************************************************************
	我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 
	思路：同样类似于fabonacii数列
	**********************************************************************************************/
	int rectCover(int number);
	
	/*********************************************************************************************
	输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 
	思路1：通过左移位数字1的方法，无论输入数有几个1，就得循环移位32次；可以将输入数减1然后跟原数与运算，每次运算就把
	最右边1变为0，这样输入数中存在几个1就循环几次,效率最高。
	**********************************************************************************************/
	int  numberOf1(int n);

	/*********************************************************************************************
	给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方
	思路1:(复杂度更低 效率高)
		1.全面考察指数的正负、底数是否为零等情况。
		2.写出指数的二进制表达，例如13表达为二进制1101。
		3.举例:10^1101 = 10^0001*10^0100*10^1000。
		4.通过&1和>>1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。
	**********************************************************************************************/
	double power(double base,int exponent);

	/*********************************************************************************************
	输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的
	后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
	思路1：类似于冒泡排序法，前偶数后奇数就交换
	思路2：再创建一个数组
	思路3：直接插入排序的思想
	**********************************************************************************************/
	void reorderArray(vector<int> &array);

	/*********************************************************************************************
	交换两个数
	**********************************************************************************************/
	void swap(int &a,int &b);

	/*********************************************************************************************
	输入一个链表，输出该链表中倒数第k个结点。 
	思路：借助vector或stack来实现
	**********************************************************************************************/
	ListNode* findKthNodeToTail(ListNode *pHeadList,unsigned int k);

	/*********************************************************************************************
	输入一个链表，反转链表后，输出链表的所有元素。 
	**********************************************************************************************/
	ListNode *reverseList(ListNode *pHead);

	/*********************************************************************************************
	输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 
	**********************************************************************************************/
	ListNode * mergeList(ListNode *pHead1,ListNode *pHead2);

	/*********************************************************************************************
	输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 
	思路：参考剑指offer
	1、首先设置标志位result = false，因为一旦匹配成功result就设为true，
	剩下的代码不会执行，如果匹配不成功，默认返回false
	2、递归思想，如果根节点相同则递归调用DoesTree1HaveTree2（），
	如果根节点不相同，则判断tree1的左子树和tree2是否相同，
	再判断右子树和tree2是否相同
	3、注意null的条件，HasSubTree中，如果两棵树都不为空才进行判断，
	DoesTree1HasTree2中，如果Tree2为空，则说明第二棵树遍历完了，即匹配成功，
	tree1为空有两种情况（1）如果tree1为空&&tree2不为空说明不匹配，
	（2）如果tree1为空，tree2为空，说明匹配。
	**********************************************************************************************/
	bool hasSubtree(TreeNode* pRootA, TreeNode* pRootB);
	bool isSubtree(TreeNode* pRootA, TreeNode* pRootB);


	/*********************************************************************************************
	操作给定的二叉树，将其变换为源二叉树的镜像。
	**********************************************************************************************/
	void bitTreeMirror(TreeNode *pRoot);

	/*********************************************************************************************
	输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 
	1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 
    思路：用左上和右下的坐标定位出一次要旋转打印的数据，一次旋转打印结束后，往对角分别前进和后退一个单位。
    提交代码时，主要的问题出在没有控制好后两个for循环，需要加入条件判断，防止出现单行或者单列的情况。
	**********************************************************************************************/
	vector<int> printMatrix(vector<vector<int> > matrix);

	/*********************************************************************************************
	定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。 

	因为 push与pop 与Solution中原有的函数名一样  此题暂未实现
	**********************************************************************************************/
	/*
	void push(int value) {

	}
	void pop() {

	}
	int top() {

	}
	int min() {

	}
	*/

	/*********************************************************************************************
	输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
	例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈
	序列的弹出序列。（注意：这两个序列的长度是相等的） 
	**********************************************************************************************/
	bool isPopOrder(vector<int> pushV,vector<int> popV);

	/*********************************************************************************************
	从上往下打印出二叉树的每个节点，同层节点从左至右打印。 
	思路：使用两个队列一个存放节点，一个存放值。先将根节点加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右
	节点，再将左右子节点加入到队列中来 
	**********************************************************************************************/
	vector<int> printFromTopToBottom(TreeNode* root);

	/*********************************************************************************************
	输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。
	假设输入的数组的任意两个数字都互不相同。 
	二叉搜索数：二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的
	二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于
	它的根结点的值； 它的左、右子树也分别为二叉排序树。

	思路1：递归，BST的后序序列的合法序列是，对于一个序列S，最后一个元素是x （也就是根），如果去掉最后一个元素的序列为T，
	那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。
	思路2：非递归，也是基于递归的思想
	**********************************************************************************************/
	bool judge(vector<int>& a, int l, int r);
	bool verifySquenceOfBST(vector<int> sequence);//没看懂！！！！！！！！！！！

	/*********************************************************************************************
	输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经
	过的结点形成一条路径。
	思路1：深度优先搜索算法 depth-first-search
	**********************************************************************************************/
	vector<vector<int> > findPath(TreeNode *root,int expectNumber);
	vector<int> depthFirstSearch(TreeNode* root,int leftNum/*leftNum为余下的数目*/);

	/*********************************************************************************************
	输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为
	复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
	思路1：   
        1、复制每个节点，如：复制节点A得到A1，将A1插入节点A后面
        2、遍历链表，A1->random = A->random->next;
        3、将链表拆分成原链表和复制后的链表
    
	**********************************************************************************************/
	RandomListNode* clone(RandomListNode* pHead);

	/*********************************************************************************************
	输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 
	思路1：方法一：非递归版
	1.核心是中序遍历的非递归算法。
	2.修改当前遍历节点与前一遍历节点的指针指向。
	思路2：方法二：递归版 （暂未实现）
	1.将左子树构造成双链表，并返回链表头节点。
	2.定位至左子树双链表最后一个节点。
	3.如果左子树链表不为空的话，将当前root追加到左子树链表。
	4.将右子树构造成双链表，并返回链表头节点。
	5.如果右子树链表不为空的话，将该链表追加到root节点之后。
	6.根据左子树链表是否为空确定返回的节点。
	**********************************************************************************************/
	TreeNode* convert(TreeNode* pRootOfTree);

	/*********************************************************************************************
	输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串
	abc,acb,bac,bca,cab和cba。 
	输入描述：输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。
	思路1：
	**********************************************************************************************/
	/*
	vector<string> permulation(string str);
	void fullPermulation(vector<string> &ans, int k, string str);//递归调用
	*/
	void swap(char &a,char &b);
	void swap(char *pa,char *pb);
	/*字符串全排列 方法2*/
	void permutation(char *pStr);
	void permutation(char *pStr,char *pBegin);

	/*********************************************************************************************
	数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
	由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 
	思路1：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。
	在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，
	否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 
	**********************************************************************************************/
	int moreThanHalfNum(vector<int> numbers);

	/*********************************************************************************************
	输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 
	思路1: 全排序O（nlogn）
	思路2: 构建最大堆 时间复杂度O（nlogk）  暂未实现
	**********************************************************************************************/
	vector<int> getLeastNumbers(vector<int> input, int k);

	/*********************************************************************************************
	连续子数组的最大和
	HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算
	连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数
	会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 
	思路1：算法时间复杂度O（n）
	用total记录累计值，maxSum记录和最大
	基于思想：对于一个数A，若是A的左边累计数非负，那么加上A能使得值不小于A，认为累计值对
	整体和是有贡献的。如果前几项累计值负数，则认为有害于总和，total记录当前值。
	此时 若和大于maxSum 则用maxSum记录下来
	**********************************************************************************************/
	int findGreatestSumOfSubArray(vector<int> array);


	/*********************************************************************************************
	整数中1出现的次数（从1到n整数中1出现的次数）
	求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、
	12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数
	区间中1出现的次数。 
	思路1： 
	设定整数点（如1、10、100等等）作为位置点m（对应n的个位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析
	根据设定的整数位置，对n进行分割，分为两部分，高位a=n/m，低位b=n%m

	当m表示百位，且百位对应的数>=2,如n=31456,m=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），
	每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1.

	当m表示百位，且百位对应的数为1,如n=31156,m=100，则a=311,b=56，此时百位对应的就是1，则共有a/10(最高两位0-30)
	次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a/10*100）+(b+1)，
	这些点百位对应为1

	当m表示百位，且百位对应的数为0,如n=31056,m=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）

	综合以上三种情况，当百位对应0或>=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1
	之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位>=2，补8会产生进位位，效果等同于(a/10+1) 
	**********************************************************************************************/
	int numberOf1Between1AndN(int n);

	/*********************************************************************************************
	把数组排成最小的数
	输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，
	则打印出这三个数字能排成的最小数字为321323。 
	**********************************************************************************************/
	string printMinNumber(vector<int> numbers);
	static bool compare(const string&str1,const string&str2);

	/*********************************************************************************************
	把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 
	习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 
	思路1：逐项求解，把前面的丑数都存起来
	**********************************************************************************************/
	int getUglyNumber(int index);

	/*********************************************************************************************
	第一个只出现一次的字符
	在一个字符串(1<=字符串长度<=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置 
	思路1：标准的书本解法，先在hash表中统计各字母出现次数，第二次扫描直接访问hash表获得次数 
	**********************************************************************************************/
	int firstNotRepeatingChar(string str);

	/*********************************************************************************************
	在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的
	总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 
	输入描述：题目保证输入的数组中没有的相同的数字
	数据范围：
	对于%50的数据,size<=10^4
	对于%75的数据,size<=10^5
	对于%100的数据,size<=2*10^5

	思路1：归并排序的思想 未弄清楚
	**********************************************************************************************/
	int inversePairs(vector<int> data);

	/*********************************************************************************************
	输入两个链表，找出它们的第一个公共结点。 
	思路1：用两个指针扫描”两个链表“，最终两个指针到达 null 或者到达公共结点。
	两个链表长度相同有公共结点，第一次就遍历到；没有公共结点，走到尾部NULL相遇，返回NULL
	两个链表长度不同有公共结点，第一遍差值就出来了，第二遍一起到公共结点；没有公共，一起到结尾NULL。
	**********************************************************************************************/
	ListNode* findFirstCommonNode( ListNode* pHead1, ListNode* pHead2);

	/*********************************************************************************************
	统计一个数字在排序数组中出现的次数
	思路1：看见有序，肯定就是二分查找了，找到第一个K 和 最后一个K 二者位置相减，值得一提的是，不要拘泥于递归，要会循环写法。 
	思路2：先用二分查找找出某个k出现的位置，然后再分别向前和向后查找总的个数
	**********************************************************************************************/
	int getFirstIndex(vector<int> &data,int k,int start,int end);
	int getLastIndex(vector<int> &data,int k,int start,int end);
	int getNumberOfK(vector<int> data ,int k);

	/*********************************************************************************************
	二叉树的深度：
	输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 
	**********************************************************************************************/
	int treeDepth(TreeNode* pRoot);

	/*********************************************************************************************
	输入一棵二叉树，判断该二叉树是否是平衡二叉树。 
	**********************************************************************************************/
	bool isBalancedBitree(TreeNode* pRoot);
	bool isBalanced(TreeNode *pRoot,int *depth);//辅助函数

	/*********************************************************************************************
	一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 
	思路：首先我们考虑这个问题的一个简单版本：一个数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这个只出现一
	次的数字。
	这个题目的突破口在哪里？题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或
	它自己都等于0 。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那
	些出现两次的数字全部在异或中抵消掉了。
	有了上面简单问题的解决方案之后，我们回到原始的问题。如果能够把原数组分为两个子数组。在每个子数组中，包含一个只出现一次
	的数字，而其它数字都出现两次。如果能够这样拆分原数组，按照前面的办法就是分别求出这两个只出现一次的数字了。
	我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其它数字都出现了
	两次，在异或中全部抵消掉了。由于这两个数字肯定不一样，那么这个异或结果肯定不为0 ，也就是说在这个结果数字的二进制表示中
	至少就有一位为1 。我们在结果数字中找到第一个为1 的位的位置，记为第N 位。现在我们以第N 位是不是1 为标准把原数组中的数
	字分成两个子数组，第一个子数组中每个数字的第N 位都为1 ，而第二个子数组的每个数字的第N 位都为0 。
	现在我们已经把原数组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其它数字都出现了两次。因此到此为止，所有
	的问题我们都已经解决。
	**********************************************************************************************/
	void findNumsAppearOnce(vector<int> data,int* num1,int *num2);
	bool isBit(int num,int indexBit);//判断num的第indexBit为是否为1
	int  findFirstBitIs(int num);//求得num的二进制表示中第一次1出现的索引

	/*********************************************************************************************
	和为S的连续正数序列
	小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟
	有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
	现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 
	输出描述：输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
	思路：等差数列思想
	根据数学公式计算:(a1+an)*n/2=s  n=an-a1+1
	(an+a1)*(an-a1+1)=2*s=k*l (k>l)
	an=(k+l-1)/2  a1=(k-l+1)/2  （k和l必须一个为偶数 一个为奇数才能保证 an a1位整数）
	**********************************************************************************************/
	vector<vector<int> > findContinuousSequence(int sum);


	/*********************************************************************************************
	输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，
	输出两个数的乘积最小的。 
	思路：a+b=sum,a和b越远乘积越小，而一头一尾两个指针往内靠近的方法找到的就是乘积最小的情况。如果是乘积最大的情况就是
	一直找到两个指针重合，每次找到一个就将之前返回的结果向量清空然后更新为新找到的。
	**********************************************************************************************/
	vector<int> findNumbersWithSum(vector<int> array,int sum);


	/*********************************************************************************************
	汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字
	符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。
	是不是很简单？OK，搞定它！
	**********************************************************************************************/
	string leftRotateString(string str, int n);


	/*********************************************************************************************
	翻转单词顺序列
	牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天
	他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，
	正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 
	思路：利用stack 入栈出栈
	**********************************************************************************************/
	string reverseSentence(string str);

	/*********************************************************************************************
	LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,
	想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My 
	God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就
	可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,
	然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 

	思路:max 记录 最大值 , min 记录  最小值 ,min ,max 都不记0
	满足条件
	1 max - min <5
	2 除0外没有重复的数字(牌)
	3 数组长度 为5
	**********************************************************************************************/
	bool isContinuous( vector<int> numbers );

	/*********************************************************************************************
	每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。
	其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的
	那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数...
	.这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想
	下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 
	思路：约瑟夫问题  递归和非递归
	递推公式
	让f[i]为i个人玩游戏报m退出最后的胜利者的编号，最后的结果自然是f[n]
	服了
	f[1] = 0;
	f[i] = (f[i - 1] + m) mod i;
	**********************************************************************************************/
	int lastRemaining(int n, int m);

	/*********************************************************************************************
	求1+2+3+...+n 
	求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
	思路：需利用逻辑与的短路特性实现递归终止，&&就是逻辑与，逻辑与有个短路特点，前面为假，后面不计算。
	**********************************************************************************************/
	int sum1ton(int n);

	/*********************************************************************************************
	写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
	思路： 
	step1:按位与是查看两个数哪些二进制位都为1，这些都是进位位，结果需左移一位，表示进位后的结果
	step2:异或是查看两个数哪些二进制位只有一个为1，这些是非进位位，可以直接加、减，结果表示非进位位进行加操作后的结果
	step3:n1&n2是查看有没有进位位了，如果有，需要重复step1、step2；如果没有，保留n1、n2上二进制为1的部分，用或将之合为一个数，即为最后结果 
	**********************************************************************************************/
	int add(int num1, int num2);

	/*********************************************************************************************
	将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 
	输入一个字符串,包括数字字母符号,可以为空;如果是合法的数值表达则返回该数字，否则返回0
	**********************************************************************************************/
	int strToInt(string str);

	/*********************************************************************************************
	数组中的重复数字
	在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个
	数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的
	数字2或者3。 
	**********************************************************************************************/
	// Parameters:
	//        numbers:     an array of integers
	//        length:      the length of array numbers
	//        duplication: (Output) the duplicated number in the array number
	// Return value:       true if the input is valid, and there are some duplications in the array number
	//                     otherwise false
	bool duplicate(int numbers[], int length, int* duplication);


	/*********************************************************************************************
	构建乘积数组
	给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*
	...*A[n-1]。不能使用除法
	思路：前后两部分分开计算
	B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]
	从左到右算 B[i]=A[0]*A[1]*...*A[i-1]
	从右到左算 B[i]*=A[i+1]*...*A[n-1] 
	**********************************************************************************************/
	vector<int> multiply(const vector<int>& A);

	/*********************************************************************************************
	请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的一个字符可以出现任意次
	（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与
	"aa.a"和"ab*a"均不匹配 
	思路：思路：只有当模式串和字符串同时等于\0，才可以认为两个串匹配。
	在匹配中，对于每个位的匹配可以分为三种情况
	1、（相应位匹配||模式串为.&&字符串不是\0）&&模式串下一位是*
	2、（相应位匹配||模式串为.&&字符串不是\0）&&模式串下一位不是*
	3、相应位不匹配&&（模式位不为.||字符串是\0）
	对应1，最复杂。分为*取0，*取1，*>=2三种情况。
	*取0对应跳过当前匹配位，继续寻找patter的下一个匹配位，str不变，pattern+2
	*取1对应当前匹配位算一次成功匹配，str+1，pattern+2
	*取>=2对应一次成功匹配，继续匹配字符串的下一位是否匹配，str+1，pattern不变
	三者取或。即只要有一种情况能匹配成功认为字符串就是匹配成功的。
	对应2，相当于一次成功匹配，str+1，pattern+1
	对应3，匹配失败，直接返回false
	**********************************************************************************************/
	bool match(char* str, char* pattern);
	bool matchCore(char* str, char* pattern);

	/*********************************************************************************************
	请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"
	都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是
	**********************************************************************************************/
	bool isNumeric(char* string);

	/*********************************************************************************************
	请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字
	符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
	输出描述：如果当前字符流没有存在出现一次的字符，返回#字符
	思路：出现的字符 和 它的出现的次数 是一种对应关系，自然联想到 哈希表的 key-value 这种对应，或者应用关联容器 map，
	可以很方便的解决这个问题。map 容器中，它的一个元素 就是一组（key，value）对应的数据 
	**********************************************************************************************/
	void insert(char ch);
	char firstAppearingOnce();

	/*********************************************************************************************
	一个链表中包含环，请找出该链表的环的入口结点。 
	思路1：set<ListNode *> nodeSet存储每个节点的指针 ,nodeSet.find(pCurr)!=nodeSet.end()说明pCurr指向环
	开始的结点，形成闭环
	思路2：如果链表中环 有n个结点，指针P1在链表上向前移动n步，然后两个指针以相同的速度向前移动。
	当第二个指针指向环的入口结点时，第一个指针已经围绕着环走了一圈又回到了入口结点。
	所以首先要得到环中结点的数目   （未实现）
	思路3：
	**********************************************************************************************/
	ListNode* entryNodeOfLoop(ListNode* pHead);

	/*********************************************************************************************
	在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 
	例如，链表1->2->3->3->4->4->5 处理后为 1->2->5 
	思路1：递归
	思路2：循环
	**********************************************************************************************/
	ListNode* deleteDuplication(ListNode* pHead);

	/*********************************************************************************************
	给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，
	同时包含指向父结点的指针（即给定的树中的next指向当前结点的父节点）。 
	思路： 
	1.二叉树为空，则返回空；
	2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；
	3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。
	**********************************************************************************************/
	TreeLinkNode* getNext(TreeLinkNode* pNode);

	/*********************************************************************************************
	请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
	思路：首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同
	* 左子树的右子树和右子树的左子树相同即可，采用递归
	* 非递归也可，采用栈或队列存取各级子树根节点
	**********************************************************************************************/
	bool isSymmetrical(TreeNode* pRoot);
	bool isSymmetrical(TreeNode* pRoot1,TreeNode* pRoot2);

	/*********************************************************************************************
	请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，
	第三行按照从左到右的顺序打印，其他行以此类推。 
	思路：
	不使用reverse!!! 借助两个stack，分别为s1和s2。
	1. 首先将根节点压入栈s1。
	2. 将s1依次出栈，保存每个节点值，并依次将每个节点的左右节点压入栈s2
	3. 将s2依次出栈，保存每个节点值，并依次将每个节点的右左节点压入本s1<注：这里是先压右子
	节点再压左子节点>
	**********************************************************************************************/
	 vector<vector<int> > printBitree(TreeNode* pRoot);

	 /*********************************************************************************************
	 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 

	 **********************************************************************************************/
	 vector<vector<int> > printBitreeUpDown(TreeNode* pRoot);

	 /*********************************************************************************************
	 请实现两个函数，分别用来序列化和反序列化二叉树 
	 这里的序列化指的是将一棵二叉树保存到文件中，反序列化就是从文件中读取二叉树结点值重构原来的二叉树。
	 **********************************************************************************************/
	 char* serializeBitree(TreeNode *root);
	 TreeNode* deserializeBitree(char *str);

	 /*********************************************************************************************
	 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，
		 5 
		/ \ 
	    3  7 
	   /\ /\ 
	  2 4 6 8 中，
	 按结点数值大小顺序第三个结点的值为4。 
	 思路：就是一遍中序遍历，找到第k个最小的值
	 **********************************************************************************************/
	 TreeNode* kthNode(TreeNode* pRoot, int k);

	 /*********************************************************************************************
	 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流
	 中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 
	 思路：创建两个优先队列，一个是大顶堆，一个是小顶堆，保证两个堆的元素个数差小于等于1，并且当元素个数差为1的时候中位数在大顶堆中
	 每次添加一个新元素，判断其与大顶堆的关系，若元素小于等于大顶堆的堆顶元素则添加到大顶堆中，否则添加到小顶堆中
	 并判断大顶堆和小顶堆中的元素个数，使其始终保证大顶堆和小顶堆的元素个数相同或者大顶堆比小顶堆的元素个数多1
	 **********************************************************************************************/
	 void insertNum(int num);
	 double getMedianNum();

	 /*********************************************************************************************
	 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，
	 那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： 
	 {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，
	 {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 
	 **********************************************************************************************/
	 vector<int> maxInWindows(const vector<int>& num, unsigned int size);

	 /*********************************************************************************************
	 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步
	 可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 
	 例如 a b c e s f c s a d e e 矩阵中包含一条字符串"bccced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的
	 第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子
	 **********************************************************************************************/
	 bool hasPath(char* matrix, int rows, int cols, char* str);
	 bool DFS(char* matrix, int rows, int cols,int i,int j, char* str);

	 /*********************************************************************************************
	 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入
	 行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不
	 能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 
	 **********************************************************************************************/
	 int movingCount(int threshold, int rows, int cols);
	 int getSum(int number);
	 int movingHelper(int threshold,int roes,int cols,int i,int j,vector<vector<int> > &flag);
};
#endif